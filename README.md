# Задание "Engine Wrapper"

Проект реализует систему инкапсуляции методов класса произвольной сигнатуры с возможностью регистрации и выполнения команд через единый интерфейс. Система предоставляет типизированный доступ к методам объектов, поддерживает значения по умолчанию для параметров, проверку типов и безопасное управление памятью.

## Пример использования
```cpp
Subject subj;
Wrapper<Subject, int, int, int> wrapper(&subj, &Subject::f3, {{"arg1", 0}, {"arg2", 0}});

Engine engine;
engine.register_command(&wrapper, "command1");

std::cout << engine.execute("command1", {{"arg1", 4}, {"arg2", 5}}) << std::endl;
```

## Архитектура проекта
```
engine_wrapper/
├── command_test.exe                 // Исполняемый файл тестов
├── CMakeLists.txt                   // Файл сборки CMake
├── command.h                        // Основной заголовочный файл (3 класса: Command, Wrapper, Engine)
├── main.cpp                         // Точка входа (запуск всех тестов)
├── test_class/
│   └── subject.h                    // Тестовый класс с методами для демонстрации
├── tests/
│   ├── test.h                       // Заголовочный файл тестов
│   └── test.cpp                     // Реализация всех unit-тестов (20 тестов)
└── README.md
```

## Основные компоненты

### 1. Класс `Command` (абстрактный базовый класс)
- Определяет интерфейс для всех команд
- Методы:
  - `execute()` - выполнение команды с заданными аргументами
  - `getParamNames()` - получение имен параметров
  - `getParamTypes()` - получение типов параметров  
  - `getReturnType()` - получение типа возвращаемого значения

### 2. Класс `Wrapper<T, ReturnType, Args...>` (шаблонный класс)
- Инкапсулирует методы класса произвольной сигнатуры
- Поддерживает:
  - Методы с любым количеством параметров (0 и более)
  - Константные и неконстантные методы
  - Значения параметров по умолчанию
  - Автоматическую генерацию имен параметров
- Проверки:
  - Nullptr при создании
  - Соответствие типов аргументов
  - Наличие обязательных параметров

### 3. Класс `Engine`
- Центральный менеджер команд
- Возможности:
  - Регистрация команд с уникальными именами
  - Выполнение команд по имени
  - Типизированное получение результатов (`execute_as<T>`)
  - Получение информации о командах (имена, типы параметров)
  - Проверка наличия команд
  - Очистка всех зарегистрированных команд
- Проверки безопасности:
  - Nullptr команды при регистрации
  - Пустые имена команд
  - Дублирование имен команд

## Особенности реализации

### 1. Безопасность и управление памятью
- Использование `std::unique_ptr<Command>` для владения командами
- Проверки на nullptr на всех уровнях
- Автоматическая очистка ресурсов
- Защита от double-free

### 2. Типобезопасность
- Проверка типов аргументов при выполнении
- Проверка типа возвращаемого значения в `execute_as<T>()`
- Информация о типах через `typeid().name()`

### 3. Гибкость
- Поддержка методов без параметров
- Поддержка константных методов
- Значения параметров по умолчанию
- Автогенерация имен параметров (`param1`, `param2`, ...)

### 4. Обработка ошибок
- Исключения при:
  - Некорректных типах аргументов
  - Отсутствии обязательных параметров
  - Дублировании имен аргументов
  - Несуществующих командах
  - Дублировании имен команд при регистрации

## Сборка проекта

### Через CMake:
```bash
# Конфигурация
cmake -B build

# Сборка
cmake --build build
```

### Через VS Code:
- Ctrl+Shift+P → CMake: Configure
- Ctrl+Shift+P → CMake: Build

## Запуск тестов
После сборки проекта:
```bash
./command_test.exe
```

## Unit-тесты (20 тестов)

### Базовые тесты
1. **test1_basic_functionality** - Базовая функциональность (умножение)
2. **test2_default_values** - Значения параметров по умолчанию
3. **test3_type_safety** - Проверка типобезопасности
4. **test4_memory_management** - Управление памятью с unique_ptr
5. **test5_error_handling** - Обработка ошибок

### Поддержка методов
6. **test6_const_methods** - Поддержка константных методов
7. **test7_command_info** - Информация о командах
8. **test8_no_parameters_method** - Методы без параметров
9. **test9_multiple_commands** - Несколько команд в одном движке

### Проверки безопасности
10. **test10_nullptr_checks** - Проверки на nullptr и пустые имена
11. **test11_exact_task_example** - Точный пример из задания
12. **test12_engine_clear_and_count** - Очистка engine и подсчет команд

### Работа с параметрами
13. **test13_generated_parameter_names** - Автогенерация имен параметров
14. **test14_missing_required_args** - Отсутствие обязательных аргументов
15. **test15_partial_defaults_error** - Ошибка частичных значений по умолчанию
16. **test16_full_defaults_work** - Работа с полными значениями по умолчанию

### Регистрация команд
17. **test17_duplicate_command_registration** - Дублирующая регистрация команд

### Проверки типов
18. **test18_default_value_type_mismatch** - Несоответствие типов значений по умолчанию
19. **test19_correct_defaults_work** - Корректная работа с defaults

### Расширенная функциональность
20. **test20_string_methods** - Строковые методы

## Примеры использования

### Регистрация и выполнение команды:
```cpp
Subject subj;
std::unique_ptr<Command> wrapper(new Wrapper<Subject, int, int, int>(
    &subj, &Subject::f3, {{"arg1", 0}, {"arg2", 0}}));

Engine engine;
engine.register_command(std::move(wrapper), "multiply");

int result = engine.execute_as<int>("multiply", {{"arg1", 4}, {"arg2", 5}});
// result = 20
```

### Использование значений по умолчанию:
```cpp
// Регистрация с defaults
auto wrapper = std::make_unique<Wrapper<Subject, int, int, int>>(
    &subj, &Subject::f3, {{"arg1", 10}, {"arg2", 20}});

// Вызов без аргументов - используются defaults
int result = engine.execute_as<int>("multiply", {});
// result = 200 (10 * 20)
```

### Методы без параметров:
```cpp
auto wrapper = std::make_unique<Wrapper<Subject, int>>(&subj, &Subject::f0);
engine.register_command(std::move(wrapper), "answer");

int result = engine.execute_as<int>("answer", {});
// result = 42
```

### Получение информации о команде:
```cpp
auto info = engine.getCommandInfo("multiply");
std::cout << "Return type: " << info.returnType << std::endl;
std::cout << "Parameters: " << info.paramNames.size() << std::endl;
```

## Ограничения и особенности
- Поддерживаются только методы классов (не свободные функции)
- Все проверки типов выполняются в runtime
- Имена типов выводятся в mangled формате
- Для каждого типа метода требуется свой конструктор Wrapper

## Требования
- C++17 или выше
- CMake 3.10 или выше
- Компилятор с поддержкой стандартной библиотеки C++17